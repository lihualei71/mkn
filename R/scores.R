#' Calculate The Cross-Validated Glmnet Coefficients As Scores
#'
#' \code{mkn_scores_glmnet_coef} calculates the cross-validated Glmnet coefficients by regressing \code{y} on the extended covariate matrix formed by \code{X} and the columns of \code{Xk} corresponding to \code{subset}.
#'
#' The scores generated by \code{mkn_scores_glmnet_coef} are likely to be relatively sparse and hence there could exist many ties. One approach to break the ties is to sort the zero entries by their Lagrangian multipliers. When deriving the p-values, it is reasonable to assume that non-zero scores always dominate the zero scores and the zero scores with larger absolute Lagragian multipliers always dominate those with smaller absolute Lagragian multipliers. The optimization theory ensures that the absolute value of the Lagragian multiplier for a non-zero score is always lambda while that for a zero score is always less than lambda. Thus, the aforementionad goal can be achieved by forming a new score as the sum of the absolute values of the score and the Lagrangian multiplier. This is implemented by setting \code{use_LR = TRUE}. Otherwise the original coefficients, with ties, will be set as the scores.
#' 
#' @param X covariate matrix
#' @param y vector. Response/Outcome
#' @param knockoffs object of class "mkn_knockoffs". See Details
#' @param subset logical vector. Indicate whether the knockoffs of each variable are included
#' @param use_LR logical. Indicate whether the Lagrangian multipliers are incorporated
#' @param nlambda positive integer. Number of lambdas for cross-validation. See \code{\link[glmnet]{cv.glmnet}}
#' @param lambda.min.ratio real in [0, 1]. The ratio between the smallest and the largest lambdas. See \code{\link[glmnet]{cv.glmnet}}
#' @param cvtype string. Should be either "lambda.min" or "lambda.1se". See \code{\link[glmnet]{coef.cv.glmnet}}
#' @param family string. See \code{\link[glmnet]{cv.glmnet}}
#' @param cores positive integer. Number of cores to fit the model. If \code{cores > 1}, the packages \code{doMC}, \code{parallel} need to be installed
#' @param ... other arguments passed into \code{\link[glmnet]{cv.glmnet}}
#'
#' @return
#' \item{mask}{a matrix of size (s, k + 1) where \code{s = sum(subset)}. The scores corresponding to the variables in \code{subset} and their knockoffs}
#' \item{unmask}{a vector of size p - s. The scores corresponding to the variables not in \code{subset}}
#' 
#' @examples
#' \donttest{
#' ## Generate knockoffs
#' n <- 100
#' p <- 50
#' rho <- 0.5
#' Sigma <- rho^stats::toeplitz(0:(p - 1))
#' mu <- rep(0, p)
#' k <- 10
#' X <- matrix(rnorm(n * p), n, p) %*% Matrix::chol(Sigma)
#' Xk <- mkn_create_gaussian(X, k, mu, Sigma, method = "sdp")
#'
#' ## Generate y
#' beta <- c(rep(1, 10), rep(0, 40))
#' y <- X %*% beta + rnorm(n)
#'
#' ## Calculate scores
#' scores_noLR <- mkn_scores_glmnet_coef(X, Xk, y, use_LR = FALSE)
#' scores_LR <- mkn_scores_glmnet_coef(X, Xk, y, use_LR = TRUE)
#' }
#' @export
mkn_scores_glmnet_coef <- function(X, y, knockoffs,
                                   subset = rep(TRUE, ncol(X)),
                                   use_LR = TRUE,
                                   nlambda = 100,
                                   lambda.min.ratio = 0.0005,
                                   cvtype = "lambda.min",
                                   family = "gaussian",
                                   cores = 1,
                                   ...){
    if (class(knockoffs) != "mkn_knockoffs"){
        stop("The input knockoffs must be of class mkn_knockoffs")
    }

    if (!("Xk" %in% names(knockoffs))){
        stop("Xk must be included in the input knockoffs")
    }
    
    if (!requireNamespace("glmnet", quietly = TRUE))
        stop("glmnet is not installed", call. = FALSE)

    parallel <- (cores > 1)
    n <- nrow(X)
    p <- ncol(X)
    if (any(!is.logical(subset))){
        tmp <- rep(FALSE, p)
        tmp[subset] <- TRUE
        subset <- tmp
    }
    inds <- rep(subset, knockoffs$k)
    Xfull <- cbind(X, knockoffs$Xk[, inds])
    Xfull <- scale(Xfull)[, ]

    if (family == "gaussian") {
        lambda_max <- max(abs(t(Xfull) %*% y))/n
        lambda_min <- lambda_max * lambda.min.ratio
        k <- (0:(nlambda - 1)) / nlambda
        lambda <- lambda_max * (lambda_min / lambda_max)^k
    }
    else {
        lambda <- NULL
    }
    fit <- glmnet::cv.glmnet(Xfull, y,
                             lambda = lambda,
                             family = family,
                             standardize = FALSE,
                             standardize.response = FALSE,
                             intercept = TRUE,
                             parallel = parallel, ...)

    lambda <- fit$lambda.min
    scores <- abs(glmnet::coef.cv.glmnet(fit, s = cvtype)[-1])
    resids <- y - glmnet::predict.cv.glmnet(fit, Xfull,
                                            s = cvtype,
                                            type = "response")
    if (use_LR){
        LR <- abs(Matrix::crossprod(Xfull, resids) / n)
        LR[scores != 0] <- lambda
        scores <- scores + LR
    }

    if (sum(!subset) > 0){
        mask <- matrix(scores[-which(!subset)], nrow = sum(subset))
    } else {
        mask <- matrix(scores, nrow = sum(subset))
    }
    unmask <- scores[1:p][!subset]

    structure(list(mask = mask, unmask = unmask), class = "mkn_scores")
}

mkn_scores_pols_coef <- function(X, y, knockoffs,
                                 subset = rep(TRUE, ncol(X)),
                                 lambda = NULL,
                                 kappa_thresh = 200){
    if (class(knockoffs) != "mkn_knockoffs"){
        stop("The input knockoffs must be of class mkn_knockoffs")
    }
    
    n <- nrow(X)
    p <- ncol(X)
    k <- knockoffs$k
    T <- Matrix::crossprod(X, y) / n
    if ("Xk" %in% names(knockoffs)){
        Tk <- Matrix::crossprod(knockoffs$Xk, y) / n
    } else if ("Tk" %in% names(knockoffs)){
        Tk <- knockoffs$Tk
    } else {
        stop("Either Xk or Tk should appear in knockoffs")
    }
    T <- c(T, Tk)
    inds <- rep(subset, k + 1)
    T <- matrix(T[inds], ncol = k + 1)
    
    if (!("Sigma" %in% names(knockoffs))){
        stop("Sigma should appear in knockoffs")
    }

    if (!("diag_s" %in% names(knockoffs))){
        stop("diag_s should appear in knockoffs")
    }

    if (sum(subset) == 0){
        return(structure(list(mask = NULL, unmask = rep(0, p)),
                         class = "mkn_scores"))
    }

    diag_s <- knockoffs$diag_s[subset]
    Omega <- knockoffs$Sigma[subset, subset] - diag(diag_s)
    Omega_eigen <- base::eigen(Omega, symmetric = TRUE)
    D <- Omega_eigen$values
    U <- Omega_eigen$vectors

    if (is.null(lambda)){
        if (max(D) > kappa_thresh * min(D)){
            lambda <- max(D) / kappa_thresh
        } else {
            lambda <- 0
        }
    }
    diag_s <- diag_s + lambda

    tdOmega <- -Omega %*% solve((k + 1) * Omega + diag(diag_s)) / diag_s
    scores <- abs(T / diag_s + as.numeric(tdOmega %*% rowSums(T)))

    structure(list(mask = scores, unmask = rep(0, sum(!subset))), class = "mkn_scores")
}
