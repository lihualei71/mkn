% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scores.R
\name{mkn_scores_glmnet_coef}
\alias{mkn_scores_glmnet_coef}
\title{Calculate The Cross-Validated Glmnet Coefficients As Scores}
\usage{
mkn_scores_glmnet_coef(X, Xk, y, subset = rep(TRUE, ncol(X)),
  use_LR = FALSE, nlambda = 100, lambda.min.ratio = 5e-04,
  cvtype = "lambda.min", family = "gaussian", cores = 1, ...)
}
\arguments{
\item{X}{covariate matrix}

\item{Xk}{knockoffs matrix. \code{ncol(Xk)} must be divisible by \code{ncol(X)}}

\item{y}{vector. Response/Outcome}

\item{subset}{logical vector. Indicate whether the knockoffs of each variable are included}

\item{use_LR}{logical. Indicate whether the Lagrangian multipliers are incorporated}

\item{nlambda}{positive integer. Number of lambdas for cross-validation. See \code{\link[glmnet]{cv.glmnet}}}

\item{lambda.min.ratio}{real in [0, 1]. The ratio between the smallest and the largest lambdas. See \code{\link[glmnet]{cv.glmnet}}}

\item{cvtype}{string. Should be either "lambda.min" or "lambda.1se". See \code{\link[glmnet]{coef.cv.glmnet}}}

\item{family}{string. See \code{\link[glmnet]{cv.glmnet}}}

\item{cores}{positive integer. Number of cores to fit the model. If \code{cores > 1}, the packages \code{doMC}, \code{parallel} need to be installed}

\item{...}{other arguments passed into \code{\link[glmnet]{cv.glmnet}}}
}
\value{
\item{mask}{a matrix of size (s, k + 1) where \code{s = sum(subset)}. The scores corresponding to the variables in \code{subset} and their knockoffs}
\item{unmask}{a vector of size p - s. The scores corresponding to the variables not in \code{subset}}
}
\description{
\code{mkn_scores_glmnet_coef} calculates the cross-validated Glmnet coefficients by regressing \code{y} on the extended covariate matrix formed by \code{X} and the columns of \code{Xk} corresponding to \code{subset}.
}
\details{
The scores generated by \code{mkn_scores_glmnet_coef} are likely to be relatively sparse and hence there could exist many ties. One approach to break the ties is to sort the zero entries by their Lagrangian multipliers. When deriving the p-values, it is reasonable to assume that non-zero scores always dominate the zero scores and the zero scores with larger absolute Lagragian multipliers always dominate those with smaller absolute Lagragian multipliers. The optimization theory ensures that the absolute value of the Lagragian multiplier for a non-zero score is always lambda while that for a zero score is always less than lambda. Thus, the aforementionad goal can be achieved by forming a new score as the sum of the absolute values of the score and the Lagrangian multiplier. This is implemented by setting \code{use_LR = TRUE}. Otherwise the original coefficients, with ties, will be set as the scores.
}
\examples{
\donttest{
## Generate knockoffs
n <- 100
p <- 50
rho <- 0.5
Sigma <- rho^stats::toeplitz(0:(p - 1))
mu <- rep(0, p)
k <- 10
X <- matrix(rnorm(n * p), n, p) \%*\% Matrix::chol(Sigma)
Xk <- mkn_create_gaussian(X, k, mu, Sigma, method = "sdp")

## Generate y
beta <- c(rep(1, 10), rep(0, 40))
y <- X \%*\% beta + rnorm(n)

## Calculate scores
scores_noLR <- mkn_scores_glmnet_coef(X, Xk, y, use_LR = FALSE)
scores_LR <- mkn_scores_glmnet_coef(X, Xk, y, use_LR = TRUE)
}
}
